近期编写图文教程

合并分支时遇到冲突，解决冲突，然后提交，再反向合并以达到和2个分支的同步

把最新的push到远程上去后，在本地修改代码，发现该乱了，想把远程的pull下来。这种是svn的想法，在git中这时使用git pull是获取不到远程仓库的内容的。在git中是通过改变head指针的方式来实现的。所以通过git reset --hard  id即可

$ git config --global user.name "Your Name"

$ git config --global user.email "email@example.com"

$ git init 将目录变成Git可以管理的仓库

$ git add file 把文件添加进去,实际上就是把文件修改添加到暂存区,可反复多次使用，添加多个文件

$ git commit -m “注释” 提交add过的文件,实际上就是把暂存区的所有内容提交到当前分支。

$ git status 命令可以让我们时刻掌握仓库当前的状态，但是看不出修改了什么

$ git diff 用来查看修改的细节

$ git log 命令显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数

$ git reset 命令来回退版本，Git必须知道当前版本是哪个版本，在Git中，用HEAD（其实为指针）表示当前版本，也就是最新的提交3628164...882e1e0，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100

$ git reflog 用来记录你的每一次命令，当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id

$ git diff HEAD -- readme.txt 命令可以查看工作区和版本库里面最新版本的区别

$ git checkout -- readme.txt 意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：

一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；

一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。

总之，就是让这个文件回到最近一次git commit或git add时的状态
git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。

$ git reset HEAD file 可以把暂存区的修改撤销掉（unstage），重新放回工作区
场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。

场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。

场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。

$ git rm 从版本库中删除该文件，并且git commit

$ git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。

$ ssh-keygen -t rsa -C "youremail@example.com"
你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。
如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。
第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：
然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容


$ git remote add origin git@server-name:path/repo-name.git 先本地后远程,要关联一个远程库

$ git push -u origin master 第一次推送master分支的所有内容；
此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；

$ git clone git@github.com:Bkengs/testGithub.git 先远程后本地

$ git stash 可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作

$ git stash apply 恢复，但是恢复后，stash内容并不删除，你需要用

$ git stash drop 来删除stash内容；

$ git stash pop 恢复的同时把stash内容也删了

$ git stash list 查看，然后恢复指定的stash，用命令： git stash apply stash@{0}

$ git branch -D <name> 丢弃一个没有被合并过的分支,强行删除

$ git remote 要查看远程库的信息，或者，用git remote -v显示更详细的信息

$ git checkout -b dev origin/dev 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支
现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支
推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送

$ git pull 也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接

$ git branch --set-upstream dev origin/dev 设置dev和origin/dev的链接
如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name

$ git branch 查看分支

$ git branch <name> 创建分支

$ git checkout <name>切换分支

$ git checkout -b <name> 创建+切换分支

$ git merge <name> 合并某分支到当前分支

$ git branch -d <name> 删除分支

$ git log --graph 命令可以看到分支合并图。
$ git log --graph --pretty=oneline --abbrev-commit

$ git merge --no-ff -m "merge with no-ff" dev 普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并

$ git tag <name> 就可以打一个新标签，也可以指定一个commit id    git tag v0.9 6224937

$ git tag 查看所有标签

$ git show <tagname> 查看标签信息创建带有说明的标签，用-a指定标签名，-m指定说明文字：

$ git tag -a v0.1 -m "version 0.1 released" 3628164

$ git tag -s <tagname> -m "blablabla..."可以用PGP签名标签

$ git push origin <tagname>可以推送一个本地标签；

$ git push origin --tags可以推送全部未推送过的本地标签；

$ git tag -d <tagname>可以删除一个本地标签；

$ git push origin :refs/tags/<tagname>可以删除一个远程标签





